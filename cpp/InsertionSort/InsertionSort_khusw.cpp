/*
    삽입정렬
    삽입정렬은 어떤 원소를 잡았을때, 그 원소가 들어갈 적당한 위치를 선정하여 넣는 방식
    선택정렬(min 보다 작은거 찾는 알고리즘),버블 정렬(앞뒤 비교하는 알고리즘) 보다는
    약간 빠름, 그러나 시간 복잡도는 여전히 O(n^2) 임. 
*/

#include <iostream>

using namespace std;

int main()
{
    int i, j, temp; // 인덱스를 의미하는 i, j, swap 을 위한 temp
    int arr[10] = {1, 10, 5, 8, 7, 6, 4, 3, 2, 9};
    for (i = 0; i < 9; i++) // size - 1 보다 작은값까지만 돌리는것은 j 와 j + 1 을 비교하기 때문
    {
        j = i;
        while (arr[j] > arr[j + 1])
        {
            // arr[j] > arr[j + 1] 과 비교를 하는 이유는
            // 오름 차순으로 정렬하기 위해서 더 작은 값이 앞으로 오게 하기 위함이다.
            // j 의 값을 줄이는 이유는 맨 첫번째 인덱스까지 비교를 진행하기 위해서이다.
            // 그리고 이 삽입정렬은 첫번째 원소가 정렬이 이미 되어 있다고 가정한 상태임
            temp = arr[j + 1];
            arr[j + 1] = arr[j];
            arr[j] = temp;
            j--;
        }
    }

    for (int i = 0; i < 10; i++)
    {
        cout << arr[i] << ' ';
    }
    return 0;
}

/*
    시간 복잡도는 O (N ^ 2) 가 되는 알고리즘이지만,
    선택정렬, 버블 정렬보다는 연산 횟수가 적음.
    만약에 들어온 데이터가 거의 대부분 정렬이 되어 있는 상태에서는
    삽입정렬은 빠른 정렬 속도를 자랑함.

    예를 들어
    2 3 4 5 6 7 8 9 10 1 일때
    2 3 4 5 6 7 8 9 1 10
    2 3 4 5 6 7 8 1 9 10
    2 3 4 5 6 7 1 8 9 10
    2 3 4 5 6 1 7 8 9 10
    2 3 4 5 1 6 7 8 9 10
    2 3 4 1 5 6 7 8 9 10
    2 3 1 4 5 6 7 8 9 10
    2 1 3 4 5 6 7 8 9 10
    1 2 3 4 5 6 7 8 9 10
    이 된다.
    1 을 제외한 나머지의 경우 연산을 아예하지 않아도
    while 의 조건문에서 걸러지기 때문에 연산을 하지않고,
    1의 경우에만 연산을 하게 되서 다른 버블정렬 선택정렬보다는 빠르다고 하는 것.
*/
