/*
    힙 정렬
    이진 트리라는 것은 데이터 표현시에 노드를 두개의 트리로 나타낸 자료구조
    이진 트리는 자식이 2개인 것을 말함(최대 자식 노드가 2개)
    자식이 없는 노드를 leaf node, 최상단 노드를 root 라 함
    complete binary tree(완전 이진 트리) 란 자식노드를 추가할 때, 왼쪽 부터 채워넣는 것을 말함
    (자식 노드의 갯수는 상관 없음, 자식노드가 2개라고 알고 있는것은 잘못 알고 있는 것.)
    힙 이란 이 완전 이진 트리를 기반으로 하는 트리구조로,
    Max Heap 과 Min Heap 이 있다.
    Max Heap 은 부모 노드가 자식 노드 보다 큰 값을 갖도록 정의된 힙을 말하고,
    Min Heap 은 그 반대임.

    힙 정렬의 경우, 어떤 하나의 노드에 의해서 정렬 구조가 무너지는 경우가 있는데,
    이를 개선하는 알고리즘을 heapify algorithm(힙 생성 알고리즘) 이라 부름.
    이 Heapify Algorithm 은 하나의 노드를 제외하고 나머지 노드들이 전부 Heap 정렬이 되어있다고 가정
    그래서 어긋난 하나의 노드에 한해서만 재 정렬을 하는 알고리즘임
    그리고 Heapify Algorithm 으로 인해서 노드의 위치를 바꿨다면,
    위치가 바뀌었기 때문에 나머지도 제대로 정렬이 되었는지 검증하는 작업이 필요하다.

    이 Heapify Algorithm 에 의한 시간 복잡도를 계산하면,
    O(logN) 이다. (왜냐, Heap 의 높이만큼 이 값이 결정 된다고함.)
    힙이 완전 이진 트리의 구조를 갖고 있기 때문에,
    높이가 하나씩 증가할 수록 2배씩 증가하기 때문에 
    결국 logN 이 되는 것. (2의 배수를 로그로)
    그리고 위의 O(logN) 은 단순히 하나의 노드에 한해서 Heapify Algorithm 을 썼다고 가정한 것이고,
    힙에 있는 모든 노드의 갯수 N 에 대해서 Heapify Algorithm 을 수행하면,
    O(NlogN) 이 된다. (높이(logN) * 총 갯수(N))

    그리고 소수찾기 에서 에라토스테네스의 체 를 쓸 때,
    N 전체를 다 돌지 않고, 루트 n 만큼만 돌아도 전체 탐색 수행이 가능한 것을 알 수 있었는데,
    힙 정렬도 마찬가지로 정확히 따지면 O(1/2NlogN) 이 된다.
    근데 빅오 기법에서 상수는 빼므로, O(NlogN)

    참고로 전체 트리 구조를 힙으로 만드는데 소요되는 시간 복잡도는
    O(NlogN) 이다. (영상에 설명된 O(N) 은 잘못된 설명이다)

    예제 입력 7 6 5 8 3 5 9 1 6 이 주어 질 때 힙정렬로 오름차순 정렬

    힙 정렬을 사용할 때 먼저, 배열을 선언하고,
    그 배열에 입력이 들어온 값 순서 그대로 넣는다
    arr[9] = {7, 6, 5, 8, 3, 5, 9, 1, 6};
    힙정렬 수행시에는 입력들어온 데이터의 절반 만큼만 
    Heapify Algorithm 을 수행하면 Heap 구조가 된다.
    예제에서는 9 / 2 = 4.5 (올림 쳐서 5회만 수행하면 되는 것)    
*/

#include <iostream>

using namespace std;

int num = 9;
int heap[9] = {7, 6, 5, 8, 3, 5, 9, 1, 6};

int main()
{
    for (int i = 1; i < num; i++)
    {
        int c = i; // c 는 child
        do
        {
            int root = (c - 1) / 2; // root 는 child 의 parent
            if (heap[root] < heap[c])
            { // 자식노드가 더 큰 경우
                // 부모 노드랑 위치를 바꿔야 함 (Max Heap 기준)
                int temp = heap[root];
                heap[root] = heap[c];
                heap[c] = temp;
            }
            c = root;
            // 값에 대한 위치도 바꿨으므로, 인덱스 위치도 서로 바꿔야함
        } while (c != 0); // c 가 맨 위로 가게 되면 index = 0 가 됨
    }
    // 여기까지는 주어진 데이터를 힙구조로 바꾸는 과정 (Max Heap)
    // 아래 부터는 크기를 줄여가면서 반복적으로 힙을 만든다고 한다.
    // 아래의 반복문을 쓰는 이유는 배열을 오름차순으로 전환하기 위해서다.
    // 위에 까지는 Max heap 형태로 배열이 구성되었다면, 아래는 배열 자체를
    // 오름차순으로 바꾸기 위해서이다.
    for (int i = num - 1; i >= 0; i--)
    {
        int temp = heap[0];
        heap[0] = heap[i];
        heap[i] = temp;
        int root = 0;
        int c = 1;
        do
        {
            c = 2 * root + 1;
            if (heap[c] < heap[c + 1] && c < i - 1)
            {
                // 이 조건문은 자식 중에서 더 큰 자식값을 찾는 것이고,
                // c < i - 1 은 c 가 범위를 벗어나는 index 가 되지 않게 하기 위해서다.
                c++;
            }
            if (heap[root] < heap[c] && c < i)
            {
                // 이 조건문은 루트 보다 자식이 더 큰 경우 일때 사용
                int temp = heap[root];
                heap[root] = heap[c];
                heap[c] = temp;
            }
            root = c;
        } while (c < i);
    }

    for (int i = 0; i < num; i++)
    {
        cout << heap[i] << ' ';
    }
}
/*
    병합정렬(merge sort) 가 정렬을 위해서 별도의 전역변수로 선언된 배열이 필요했던 것과는 다르게,
    힙 정렬은 별도의 추갖거인 배열 선언 없이 오로지 heap[] 이라는 배열만으로 힙정렬을 수행함.   
*/